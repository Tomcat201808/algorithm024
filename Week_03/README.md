***学习笔记***

***1.递归公式***

递归的特点介绍：

- 递归需要满足的三个条件
  - 一个问题的解可以分解为几个子问题的解
  - 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
  - 存在递归终止条件

递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。

递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。

- 几个关键点
  - 编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。
  - 函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。
  - 不要人肉进行递归
  - 找最近重复子问题
  - 数学归纳法的思维
- Java代码模板

```java
public void recur(int level, int param) {
  //terminator
  if (level > MAX_LEVEL) {
    // process result
    return;
  }
  // process current logic
  process(level, param);
  
  // drill down
  recur(level: level + 1, newParam);
  
  // restore current status
}
```

## 

***2.分治***

- 分治是一种特殊的递归，归根到底就是找重复性
  - 最优重复性：动态规划
  - 最近重复性：分治、回溯等
- 和递归非要说有什么差别的话，可以理解为拆分完之后，有个合并的过程
- 代码模板

```java
private static int divide_conquer(Problem, problem){
    // 到达最小问题，叶子结点
    if (problem == null) {
        int res = process_last_result();
        return res;    
    }
    // 处当前逻辑，如何把这个大问题拆分成小问题
    subProlems = split_prolem(problem);
    // 下探一层，解决更细节的问题
    res0 = divide_conquer(subProblems[0]);
    res1 = divide_conquer(subProblems[1]);
    // 对结果数据进行合并
    result = process_result(res0, res1);
    // 返回结果
    return result;
}
```

****

***3.回溯***

- 概念

> 回溯法采用试错的思想，它尝试分步的去解决一个问题，在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至上几步的计算，再通过其它的可能的分步解答在此尝试寻找问题的答案。
>
> 回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤之后会出现两种情况
>
> 1. 找到一个可能存在的正确的答案
> 2. 在尝试了所有可能的分步方法后宣告该问题没有答案
>
> 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

简而言之，就是在每一层里去试就行了,最典型的是八皇后问题以及数独上面.

- 小结

回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。



***4.总结与提升***

本周学习是春节假期，坦白说，是有点懒惰，也是在找借口，躲在自己的舒适区，没有使用五毒神掌来刷题，巩固所学的知识和代码的模板，这是很不利的。我想对大多数的同学都有类似的情况吧。

已经收假回来了，年前说好的模板，通关算法和数据结构，一定是要跳出舒适区的，要不断地审视自己能力上的缺陷，要不断地重复代码，不断地写，这样才会有感觉，才知道套路。