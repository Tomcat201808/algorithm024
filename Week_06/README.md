学习笔记

一、dp模板： 

1､找子问题， 2､定义状态数组 3､定义dp方程

状态数组含义不一样，dp方程也不一样，可以是自顶向下，也可以是自底向上

**空间复杂度可以有不同方案：**

1､状态数组为子问题的个数，通常为二维数组

2､二维状态数组降成一维 

3､一维数组降成滚动数组

4､直接在入参数组上改，不用另外申请空间。 



二、关于爬楼梯的经典问题：

 覃超老师视频里面的问题：如果不能连着走两步一样的。 感觉是个脑筋急转弯的题? 这里写个DP解法，首先还是基于基础版的，因为可以跳两步和跳一步，所以比如说7的话，那就是5跳2，6跳1得到7，然后我每次记录下来前面的所有的结果，看5里面所有结尾为1的走法+2就道7，6里面所有结尾为2的走法+1则到7！！ 所有就是用一个DP数组记录下来前面所有的结果，然后遍历每个得到新的即可。具体看代码
def qcQuiz(n):
\#这里1和2就都只有一种结果了
if n ==1 or n==2:
return n
\#初始化一个dp数组，长度+1是为了方便，第一步就对应了下标为1
dp = [[] for _ in range(n+1)]
\#第一个步的走法就只能是‘1’，同理第二步的走法在这里只能是‘2’
dp[1].append('1')
dp[2].append('2')
\#从第三步开始
for i in range(3,n+1):
\#先拿到前面两步的结果
s1 = dp[i-1]
s2 = dp[i-2]
\#对前一步里面，所有结尾不为1的结果再+1 就是当前步数的结果
for each in s1:
if each[-1]!='1':
dp[i].append(each+'1')
\#同理在两步前的结果里面，所谓结尾不为2的再+2就到了当前步数
for each in s2:
if each[-1]!='2':
dp[i].append(each+'2')
print(dp)
\#最后返回长度就是所要的结果
return len(dp[-1]) 



三、动态规划

DP方程非常重要，要善于找出DP方程，使用if else 和for loop去解决问题，千万不能人肉，一个是数学上不严谨，二是人类认知的局限性。稍微复杂一点，就极容易出错。

